#!/usr/bin/env python3

import json
import os
import sys
from datetime import datetime

# Importar utilidades
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Definición de cadenas de ataque comunes en IoT
ATTACK_CHAINS = {
    "lateral_movement": {
        "description": "Movimiento lateral a través de dispositivos IoT",
        "severity": "CRÍTICO",
        "required_vulnerabilities": ["default_credentials", "weak_encryption"],
        "impact": "Permite al atacante moverse lateralmente en la red usando dispositivos IoT como punto de entrada",
        "mitigation": "Segmentar la red, implementar autenticación fuerte y cifrado robusto en todos los dispositivos"
    },
    "data_exfiltration": {
        "description": "Exfiltración de datos a través de dispositivos IoT",
        "severity": "ALTO",
        "required_vulnerabilities": ["weak_encryption", "data_exposure"],
        "impact": "Permite al atacante extraer datos sensibles a través de dispositivos IoT comprometidos",
        "mitigation": "Implementar cifrado de datos en reposo y en tránsito, monitorizar el tráfico de red"
    },
    "botnet_recruitment": {
        "description": "Reclutamiento para botnet de dispositivos IoT",
        "severity": "ALTO",
        "required_vulnerabilities": ["default_credentials", "open_telnet", "outdated_firmware"],
        "impact": "Permite al atacante incorporar dispositivos a una botnet para ataques DDoS u otros fines maliciosos",
        "mitigation": "Actualizar firmware, cambiar credenciales por defecto, deshabilitar servicios innecesarios"
    },
    "persistent_access": {
        "description": "Acceso persistente a la red a través de dispositivos IoT",
        "severity": "CRÍTICO",
        "required_vulnerabilities": ["outdated_firmware", "default_credentials"],
        "impact": "Permite al atacante mantener acceso persistente a la red incluso después de medidas de remediación estándar",
        "mitigation": "Actualizar firmware, implementar monitorización continua, realizar auditorías de seguridad periódicas"
    },
    "privacy_breach": {
        "description": "Violación de privacidad a través de dispositivos IoT",
        "severity": "ALTO",
        "required_vulnerabilities": ["insecure_web_interface", "weak_encryption"],
        "impact": "Permite al atacante acceder a información privada (video, audio, datos personales)",
        "mitigation": "Implementar cifrado fuerte, actualizar interfaces web, limitar acceso a datos sensibles"
    }
}


def correlate_vulnerabilities(iot_devices):
    """
    Correlaciona vulnerabilidades detectadas para identificar posibles cadenas de ataque

    Args:
        iot_devices (dict): Diccionario con información de dispositivos IoT y sus vulnerabilidades

    Returns:
        dict: Cadenas de ataque identificadas y su información
    """
    try:
        # Verificar si hay vulnerabilidades detectadas
        if not iot_devices or not iot_devices.get("possible_vulnerabilities"):
            print("\n[!] No se detectaron vulnerabilidades para correlacionar")
            return {}

        # Inicializar resultados
        attack_chains = {
            "identified_chains": [],
            "risk_score": 0,
            "critical_chains_count": 0,
            "high_risk_chains_count": 0
        }

        # Obtener lista de vulnerabilidades detectadas
        detected_vulns = [vuln["name"]
                          for vuln in iot_devices.get("possible_vulnerabilities", [])]

        # Correlacionar vulnerabilidades con cadenas de ataque conocidas
        for chain_id, chain_info in ATTACK_CHAINS.items():
            # Verificar si las vulnerabilidades requeridas están presentes
            required_vulns = chain_info["required_vulnerabilities"]
            matching_vulns = [
                vuln for vuln in required_vulns if vuln in detected_vulns]

            # Calcular porcentaje de coincidencia
            match_percentage = (len(matching_vulns) /
                                len(required_vulns)) * 100

            # Si hay coincidencia significativa (más del 50%), añadir a cadenas identificadas
            if match_percentage >= 50:
                # Calcular nivel de riesgo basado en severidad y porcentaje de coincidencia
                risk_level = calculate_risk_level(
                    chain_info["severity"], match_percentage)

                # Añadir cadena de ataque a los resultados
                attack_chains["identified_chains"].append({
                    "chain_id": chain_id,
                    "description": chain_info["description"],
                    "severity": chain_info["severity"],
                    "matching_vulnerabilities": matching_vulns,
                    "missing_vulnerabilities": [v for v in required_vulns if v not in matching_vulns],
                    "match_percentage": round(match_percentage, 2),
                    "risk_level": risk_level,
                    "impact": chain_info["impact"],
                    "mitigation": chain_info["mitigation"]
                })

                # Actualizar contadores
                if chain_info["severity"] == "CRÍTICO":
                    attack_chains["critical_chains_count"] += 1
                elif chain_info["severity"] == "ALTO":
                    attack_chains["high_risk_chains_count"] += 1

        # Calcular puntuación de riesgo global
        if attack_chains["identified_chains"]:
            # Fórmula: (Críticos * 10 + Altos * 5) * (Promedio de porcentaje de coincidencia / 100)
            avg_match = sum(chain["match_percentage"]
                            for chain in attack_chains["identified_chains"]) / len(attack_chains["identified_chains"])
            attack_chains["risk_score"] = round((attack_chains["critical_chains_count"] * 10 +
                                                 attack_chains["high_risk_chains_count"] * 5) *
                                                (avg_match / 100), 2)

        return attack_chains

    except Exception as e:
        print(f"\n[!] Error al correlacionar vulnerabilidades: {e}")
        return {}


def calculate_risk_level(severity, match_percentage):
    """
    Calcula el nivel de riesgo basado en la severidad y el porcentaje de coincidencia

    Args:
        severity (str): Nivel de severidad (CRÍTICO, ALTO, MEDIO, BAJO)
        match_percentage (float): Porcentaje de coincidencia de vulnerabilidades

    Returns:
        str: Nivel de riesgo calculado
    """
    # Asignar valor numérico a la severidad
    severity_values = {
        "CRÍTICO": 4,
        "ALTO": 3,
        "MEDIO": 2,
        "BAJO": 1
    }

    severity_value = severity_values.get(
        severity, 2)  # Valor por defecto: MEDIO

    # Calcular nivel de riesgo
    risk_score = severity_value * (match_percentage / 100)

    # Determinar nivel de riesgo basado en la puntuación
    if risk_score >= 3.5:
        return "CRÍTICO"
    elif risk_score >= 2.5:
        return "ALTO"
    elif risk_score >= 1.5:
        return "MEDIO"
    else:
        return "BAJO"


def display_attack_chains(attack_chains, voice_enabled=True):
    """
    Muestra las cadenas de ataque identificadas

    Args:
        attack_chains (dict): Diccionario con información de cadenas de ataque
        voice_enabled (bool): Indica si el asistente de voz está habilitado
    """
    try:
        from utils.voice_utils import speak_text

        if not attack_chains or not attack_chains.get("identified_chains"):
            message = "No se identificaron cadenas de ataque potenciales"
            print(f"\n[!] {message}")
            speak_text(message, voice_enabled)
            return

        print(f"\n{'=' * 60}")
        print(f"ANÁLISIS DE CADENAS DE ATAQUE POTENCIALES")
        print(f"{'=' * 60}\n")

        # Anunciar con voz el resultado general
        chains_count = len(attack_chains.get("identified_chains", []))
        risk_score = attack_chains.get("risk_score", 0)

        speak_text(
            f"Se han identificado {chains_count} posibles cadenas de ataque con una puntuación de riesgo global de {risk_score}.",
            voice_enabled
        )

        # Mostrar puntuación de riesgo global
        print(f"PUNTUACIÓN DE RIESGO GLOBAL: {risk_score}")
        print(
            f"Cadenas críticas: {attack_chains.get('critical_chains_count', 0)}")
        print(
            f"Cadenas de alto riesgo: {attack_chains.get('high_risk_chains_count', 0)}")
        print(f"{'-' * 60}\n")

        # Mostrar cadenas de ataque identificadas
        print("CADENAS DE ATAQUE IDENTIFICADAS:")
        print(f"{'-' * 60}")

        # Ordenar por nivel de riesgo (crítico primero)
        sorted_chains = sorted(attack_chains.get("identified_chains", []),
                               key=lambda x: (0 if x["risk_level"] == "CRÍTICO" else
                                              1 if x["risk_level"] == "ALTO" else
                                              2 if x["risk_level"] == "MEDIO" else 3,
                                              -x["match_percentage"]))

        for chain in sorted_chains:
            print(f"Cadena: {chain['chain_id'].upper()}")
            print(f"Descripción: {chain['description']}")
            print(f"Nivel de riesgo: {chain['risk_level']}")
            print(f"Coincidencia: {chain['match_percentage']}%")
            print(
                f"Vulnerabilidades coincidentes: {', '.join(chain['matching_vulnerabilities'])}")

            if chain['missing_vulnerabilities']:
                print(
                    f"Vulnerabilidades faltantes: {', '.join(chain['missing_vulnerabilities'])}")

            print(f"Impacto: {chain['impact']}")
            print(f"Mitigación: {chain['mitigation']}")
            print(f"{'-' * 60}")

        # Mostrar recomendaciones basadas en las cadenas de ataque
        print("\nRECOMENDACIONES DE MITIGACIÓN PRIORITARIAS:")
        print(f"{'-' * 60}")

        # Recopilar y deduplicar recomendaciones
        recommendations = []
        for chain in sorted_chains:
            if chain["mitigation"] not in recommendations:
                recommendations.append(chain["mitigation"])

        for i, recommendation in enumerate(recommendations, 1):
            print(f"{i}. {recommendation}")

    except Exception as e:
        print(f"\n[!] Error al mostrar cadenas de ataque: {e}")


def export_attack_chains(attack_chains, target_ip, export_format='json'):
    """
    Exporta las cadenas de ataque identificadas a un archivo

    Args:
        attack_chains (dict): Diccionario con información de cadenas de ataque
        target_ip (str): La dirección IP analizada
        export_format (str): Formato de exportación ('json', 'txt')

    Returns:
        str: Ruta del archivo generado
    """
    try:
        # Crear directorio de resultados si no existe
        output_dir = "resultados_analisis"
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Generar nombre de archivo con timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{output_dir}/attack_chains_{target_ip.replace('.', '_')}_{timestamp}"

        if export_format.lower() == 'json':
            # Exportar a JSON
            file_path = f"{filename}.json"
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(attack_chains, f, indent=4, ensure_ascii=False)

        elif export_format.lower() == 'txt':
            # Exportar a TXT (formato legible)
            file_path = f"{filename}.txt"
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(f"ANÁLISIS DE CADENAS DE ATAQUE PARA: {target_ip}\n")
                f.write(f"{'=' * 60}\n\n")
                f.write(
                    f"Fecha y hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

                # Escribir puntuación de riesgo global
                f.write(
                    f"PUNTUACIÓN DE RIESGO GLOBAL: {attack_chains.get('risk_score', 0)}\n")
                f.write(
                    f"Cadenas críticas: {attack_chains.get('critical_chains_count', 0)}\n")
                f.write(
                    f"Cadenas de alto riesgo: {attack_chains.get('high_risk_chains_count', 0)}\n")
                f.write(f"{'-' * 60}\n\n")

                # Escribir cadenas de ataque identificadas
                f.write("CADENAS DE ATAQUE IDENTIFICADAS:\n")
                f.write(f"{'-' * 60}\n")

                # Ordenar por nivel de riesgo (crítico primero)
                sorted_chains = sorted(attack_chains.get("identified_chains", []),
                                       key=lambda x: (0 if x["risk_level"] == "CRÍTICO" else
                                                      1 if x["risk_level"] == "ALTO" else
                                                      2 if x["risk_level"] == "MEDIO" else 3,
                                                      -x["match_percentage"]))

                for chain in sorted_chains:
                    f.write(f"Cadena: {chain['chain_id'].upper()}\n")
                    f.write(f"Descripción: {chain['description']}\n")
                    f.write(f"Nivel de riesgo: {chain['risk_level']}\n")
                    f.write(f"Coincidencia: {chain['match_percentage']}%\n")
                    f.write(
                        f"Vulnerabilidades coincidentes: {', '.join(chain['matching_vulnerabilities'])}\n")

                    if chain['missing_vulnerabilities']:
                        f.write(
                            f"Vulnerabilidades faltantes: {', '.join(chain['missing_vulnerabilities'])}\n")

                    f.write(f"Impacto: {chain['impact']}\n")
                    f.write(f"Mitigación: {chain['mitigation']}\n")
                    f.write(f"{'-' * 60}\n")

                # Escribir recomendaciones basadas en las cadenas de ataque
                f.write("\nRECOMENDACIONES DE MITIGACIÓN PRIORITARIAS:\n")
                f.write(f"{'-' * 60}\n")

                # Recopilar y deduplicar recomendaciones
                recommendations = []
                for chain in sorted_chains:
                    if chain["mitigation"] not in recommendations:
                        recommendations.append(chain["mitigation"])

                for i, recommendation in enumerate(recommendations, 1):
                    f.write(f"{i}. {recommendation}\n")

        else:
            print(
                f"[!] Formato de exportación '{export_format}' no soportado.")
            return None

        print(
            f"\n[+] Resultados de cadenas de ataque exportados a: {file_path}")
        return file_path

    except Exception as e:
        print(f"\n[!] Error al exportar resultados de cadenas de ataque: {e}")
        return None


def analyze_attack_vectors(iot_devices, target_ip, voice_enabled=True):
    """
    Analiza vectores de ataque potenciales basados en vulnerabilidades detectadas

    Args:
        iot_devices (dict): Diccionario con información de dispositivos IoT y sus vulnerabilidades
        target_ip (str): La dirección IP analizada
        voice_enabled (bool): Indica si el asistente de voz está habilitado

    Returns:
        dict: Cadenas de ataque identificadas y su información
    """
    try:
        # Correlacionar vulnerabilidades para identificar cadenas de ataque
        attack_chains = correlate_vulnerabilities(iot_devices)

        # Mostrar resultados
        display_attack_chains(attack_chains, voice_enabled)

        # Exportar resultados
        export_option = input(
            "\n¿Deseas exportar los resultados del análisis de cadenas de ataque? (json/txt/n) [json]: ").strip().lower() or "json"
        if export_option in ["json", "txt"]:
            export_path = export_attack_chains(
                attack_chains, target_ip, export_option)

        return attack_chains

    except Exception as e:
        print(f"\n[!] Error al analizar vectores de ataque: {e}")
        return {}


# Función principal para pruebas independientes
if __name__ == "__main__":
    # Ejemplo de uso independiente
    if len(sys.argv) > 1:
        target_ip = sys.argv[1]
        # Cargar resultados de un análisis previo de IoT
        try:
            from glob import glob
            # Buscar el archivo de resultados más reciente para la IP
            result_files = glob(
                f"resultados_analisis/iot_analisis_{target_ip.replace('.', '_')}*.json")
            if result_files:
                latest_file = max(result_files, key=os.path.getctime)
                print(
                    f"\n[*] Cargando resultados previos desde: {latest_file}")
                with open(latest_file, 'r', encoding='utf-8') as f:
                    iot_devices = json.load(f)

                # Analizar vectores de ataque
                analyze_attack_vectors(iot_devices, target_ip)
            else:
                print(
                    f"\n[!] No se encontraron resultados previos para la IP {target_ip}")
        except Exception as e:
            print(f"\n[!] Error al cargar resultados previos: {e}")
    else:
        print("\n[!] Uso: python vulnerability_correlation.py <dirección_ip>")