#!/usr/bin/env python3

import requests
import re
import json
import os
import time
import random
from datetime import datetime
from urllib.parse import urlparse, urljoin
from bs4 import BeautifulSoup

# Lista de agentes de usuario para rotar y evitar bloqueos
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 Edg/92.0.902.55"
]

# Patrones de inyección SQL básicos para pruebas
SQL_INJECTION_PAYLOADS = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "\" OR 1=1 --",
    "' OR '1'='1' --",
    "admin' --",
    "1' OR '1' = '1",
    "1 OR 1=1",
    "' UNION SELECT 1,2,3 --",
    "' UNION SELECT username,password,3 FROM users --"
]

# Patrones de XSS básicos para pruebas
XSS_PAYLOADS = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg onload=alert('XSS')>",
    "javascript:alert('XSS')",
    "<iframe src=javascript:alert('XSS')>",
    "'><script>alert('XSS')</script>",
    "\"><script>alert('XSS')</script>"
]

# Patrones para detectar errores de SQL en respuestas
SQL_ERROR_PATTERNS = [
    "SQL syntax",
    "mysql_fetch",
    "ORA-\d{5}",
    "PostgreSQL",
    "SQLite3::",
    "Microsoft SQL",
    "ODBC Driver",
    "DB2 SQL error",
    "Unclosed quotation mark",
    "You have an error in your SQL syntax",
    "Warning: mysql_",
    "Warning: pg_",
    "Warning: mssql_",
    "OLE DB Provider",
    "SQLSTATE"
]


def get_random_user_agent():
    """Devuelve un agente de usuario aleatorio de la lista"""
    return random.choice(USER_AGENTS)


def create_results_directory():
    """Crea el directorio para almacenar los resultados si no existe"""
    output_dir = "resultados_vulnerabilidades_web"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    return output_dir


def normalize_url(url):
    """Normaliza una URL asegurando que tenga el formato correcto

    Args:
        url (str): URL a normalizar

    Returns:
        str: URL normalizada
    """
    # Asegurar que la URL comienza con http:// o https://
    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url

    # Eliminar barras diagonales duplicadas (excepto en http:// o https://)
    url = re.sub(r'(?<!:)//+', '/', url)

    # Asegurar que hay una barra después del dominio si no hay ruta
    parsed = urlparse(url)
    if not parsed.path:
        url += '/'

    return url


def check_website_availability(url, timeout=10):
    """Verifica si un sitio web está disponible

    Args:
        url (str): URL a verificar
        timeout (int): Tiempo de espera para la solicitud

    Returns:
        bool: True si el sitio está disponible, False en caso contrario
    """
    try:
        headers = {"User-Agent": get_random_user_agent()}
        response = requests.head(url, timeout=timeout,
                                 headers=headers, allow_redirects=True)

        # Si HEAD no funciona, intentar con GET
        if response.status_code == 405:  # Método no permitido
            response = requests.get(
                url, timeout=timeout, headers=headers, allow_redirects=True)

        return response.status_code < 400
    except Exception as e:
        print(f"[!] Error al verificar disponibilidad de {url}: {e}")
        return False


def extract_forms(url):
    """Extrae todos los formularios de una página web

    Args:
        url (str): URL de la página

    Returns:
        list: Lista de formularios encontrados (objetos BeautifulSoup)
    """
    try:
        headers = {"User-Agent": get_random_user_agent()}
        response = requests.get(url, headers=headers)
        soup = BeautifulSoup(response.text, 'html.parser')
        return soup.find_all('form')
    except Exception as e:
        print(f"[!] Error al extraer formularios de {url}: {e}")
        return []


def analyze_form_security(form, base_url):
    """Analiza la seguridad de un formulario

    Args:
        form: Objeto BeautifulSoup que representa un formulario
        base_url (str): URL base de la página

    Returns:
        dict: Resultados del análisis de seguridad del formulario
    """
    form_analysis = {
        "action": form.get('action', ''),
        "method": form.get('method', 'get').lower(),
        "inputs": [],
        "vulnerabilities": []
    }

    # Normalizar la URL de acción
    if form_analysis["action"]:
        form_analysis["action"] = urljoin(base_url, form_analysis["action"])
    else:
        form_analysis["action"] = base_url

    # Analizar campos de entrada
    for input_field in form.find_all(['input', 'textarea', 'select']):
        input_type = input_field.get('type', '')
        input_name = input_field.get('name', '')
        input_value = input_field.get('value', '')

        if input_name:
            form_analysis["inputs"].append({
                "name": input_name,
                "type": input_type,
                "value": input_value
            })

    # Verificar problemas de seguridad básicos
    if form_analysis["method"] == "get" and any(input_field.get('type') == 'password' for input_field in form.find_all('input')):
        form_analysis["vulnerabilities"].append({
            "type": "Método inseguro",
            "description": "El formulario utiliza el método GET para enviar contraseñas, lo que puede exponer información sensible en las URLs y logs del servidor.",
            "severity": "Alta",
            "recommendation": "Cambiar el método del formulario a POST para datos sensibles."
        })

    # Verificar si hay tokens CSRF
    csrf_found = False
    for input_field in form.find_all('input', type='hidden'):
        input_name = input_field.get('name', '').lower()
        if any(csrf_term in input_name for csrf_term in ['csrf', 'token', 'nonce', '_token']):
            csrf_found = True
            break

    if not csrf_found and form_analysis["method"] == "post":
        form_analysis["vulnerabilities"].append({
            "type": "Posible CSRF",
            "description": "No se detectó un token CSRF en el formulario, lo que podría permitir ataques de falsificación de solicitudes entre sitios.",
            "severity": "Media",
            "recommendation": "Implementar tokens CSRF para proteger los formularios POST."
        })

    return form_analysis


def test_sql_injection(url, params):
    """Prueba vulnerabilidades de inyección SQL básicas

    Args:
        url (str): URL a probar
        params (dict): Parámetros a enviar

    Returns:
        dict: Resultados de las pruebas de inyección SQL
    """
    results = {
        "vulnerable": False,
        "payloads_tested": [],
        "successful_payloads": [],
        "error_patterns_found": []
    }

    original_response = None
    try:
        # Obtener respuesta original para comparación
        headers = {"User-Agent": get_random_user_agent()}
        original_response = requests.get(url, params=params, headers=headers)
        original_content_length = len(original_response.text)
        original_status_code = original_response.status_code
    except Exception as e:
        print(f"[!] Error al obtener respuesta original: {e}")
        return results

    # Probar cada payload de inyección SQL
    for payload in SQL_INJECTION_PAYLOADS:
        results["payloads_tested"].append(payload)

        # Crear una copia de los parámetros y modificar cada uno con el payload
        for param_name in params.keys():
            injection_params = params.copy()
            injection_params[param_name] = payload

            try:
                response = requests.get(
                    url, params=injection_params, headers=headers)

                # Buscar patrones de error SQL en la respuesta
                for pattern in SQL_ERROR_PATTERNS:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        results["vulnerable"] = True
                        results["successful_payloads"].append({
                            "payload": payload,
                            "param": param_name,
                            "error_pattern": pattern
                        })
                        if pattern not in results["error_patterns_found"]:
                            results["error_patterns_found"].append(pattern)

                # Detectar cambios significativos en la respuesta
                content_length_diff = abs(
                    len(response.text) - original_content_length)
                if (content_length_diff > 500 or
                    response.status_code != original_status_code or
                        (response.status_code == 200 and original_status_code != 200)):
                    results["vulnerable"] = True
                    results["successful_payloads"].append({
                        "payload": payload,
                        "param": param_name,
                        "response_change": f"Cambio en longitud: {content_length_diff}, Código original: {original_status_code}, Nuevo código: {response.status_code}"
                    })

            except Exception as e:
                print(
                    f"[!] Error al probar inyección SQL con payload {payload}: {e}")

    return results


def test_xss_vulnerability(url, params):
    """Prueba vulnerabilidades XSS básicas

    Args:
        url (str): URL a probar
        params (dict): Parámetros a enviar

    Returns:
        dict: Resultados de las pruebas XSS
    """
    results = {
        "vulnerable": False,
        "payloads_tested": [],
        "successful_payloads": []
    }

    headers = {"User-Agent": get_random_user_agent()}

    # Probar cada payload XSS
    for payload in XSS_PAYLOADS:
        results["payloads_tested"].append(payload)

        # Crear una copia de los parámetros y modificar cada uno con el payload
        for param_name in params.keys():
            injection_params = params.copy()
            injection_params[param_name] = payload

            try:
                response = requests.get(
                    url, params=injection_params, headers=headers)

                # Verificar si el payload se refleja en la respuesta sin codificar
                if payload in response.text:
                    results["vulnerable"] = True
                    results["successful_payloads"].append({
                        "payload": payload,
                        "param": param_name,
                        "reflected": True
                    })

            except Exception as e:
                print(f"[!] Error al probar XSS con payload {payload}: {e}")

    return results


def analyze_security_headers(url):
    """Analiza las cabeceras de seguridad de un sitio web

    Args:
        url (str): URL a analizar

    Returns:
        dict: Resultados del análisis de cabeceras de seguridad
    """
    security_headers = {
        "Content-Security-Policy": {
            "present": False,
            "value": "",
            "description": "Ayuda a prevenir ataques XSS y de inyección de datos"
        },
        "X-XSS-Protection": {
            "present": False,
            "value": "",
            "description": "Filtro XSS integrado en navegadores modernos"
        },
        "X-Frame-Options": {
            "present": False,
            "value": "",
            "description": "Previene ataques de clickjacking"
        },
        "X-Content-Type-Options": {
            "present": False,
            "value": "",
            "description": "Previene MIME-sniffing"
        },
        "Strict-Transport-Security": {
            "present": False,
            "value": "",
            "description": "Fuerza conexiones HTTPS (HSTS)"
        },
        "Referrer-Policy": {
            "present": False,
            "value": "",
            "description": "Controla la información del referrer enviada"
        },
        "Feature-Policy": {
            "present": False,
            "value": "",
            "description": "Controla qué características y APIs puede usar el sitio"
        },
        "Permissions-Policy": {
            "present": False,
            "value": "",
            "description": "Versión más nueva de Feature-Policy"
        }
    }

    missing_headers = []

    try:
        headers = {"User-Agent": get_random_user_agent()}
        response = requests.get(url, headers=headers)

        for header_name in security_headers.keys():
            if header_name.lower() in [h.lower() for h in response.headers]:
                security_headers[header_name]["present"] = True
                # Obtener el valor real de la cabecera (case-insensitive)
                for h, v in response.headers.items():
                    if h.lower() == header_name.lower():
                        security_headers[header_name]["value"] = v
                        break
            else:
                missing_headers.append(header_name)

    except Exception as e:
        print(f"[!] Error al analizar cabeceras de seguridad: {e}")

    return {
        "security_headers": security_headers,
        "missing_headers": missing_headers
    }


def scan_web_vulnerabilities(target_url, scan_depth=2, voice_enabled=True):
    """Escanea vulnerabilidades en una aplicación web

    Args:
        target_url (str): URL objetivo a escanear
        scan_depth (int): Profundidad del escaneo (1-3)
        voice_enabled (bool): Indica si el asistente de voz está habilitado

    Returns:
        dict: Resultados del escaneo de vulnerabilidades
    """
    print(f"\n[*] Iniciando análisis de vulnerabilidades web en {target_url}")
    print(f"[*] Profundidad de escaneo: {scan_depth}")
    print("[*] Este proceso puede tardar varios minutos...\n")

    # Normalizar URL
    target_url = normalize_url(target_url)

    # Verificar disponibilidad del sitio
    print(f"[*] Verificando disponibilidad de {target_url}...")
    if not check_website_availability(target_url):
        print(f"\n[!] El sitio {target_url} no está disponible o no responde.")
        print("[!] Verifica la URL e intenta nuevamente.")
        return None

    print(f"[+] Sitio {target_url} disponible. Iniciando análisis...\n")

    # Inicializar resultados
    scan_results = {
        "target_url": target_url,
        "scan_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "scan_depth": scan_depth,
        "security_headers": {},
        "forms_analyzed": [],
        "sql_injection_tests": {},
        "xss_tests": {},
        "vulnerabilities_summary": {
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
    }

    # Analizar cabeceras de seguridad
    print("[*] Analizando cabeceras de seguridad...")
    headers_analysis = analyze_security_headers(target_url)
    scan_results["security_headers"] = headers_analysis

    # Contar cabeceras faltantes como vulnerabilidades de severidad baja
    missing_headers_count = len(headers_analysis["missing_headers"])
    if missing_headers_count > 0:
        scan_results["vulnerabilities_summary"]["low"] += 1
        print(
            f"[!] Se encontraron {missing_headers_count} cabeceras de seguridad faltantes.")

    # Extraer y analizar formularios
    print("[*] Buscando y analizando formularios...")
    forms = extract_forms(target_url)
    print(f"[+] Se encontraron {len(forms)} formularios.")

    for i, form in enumerate(forms, 1):
        print(f"[*] Analizando formulario {i}/{len(forms)}...")
        form_analysis = analyze_form_security(form, target_url)
        scan_results["forms_analyzed"].append(form_analysis)

        # Contar vulnerabilidades en formularios
        for vuln in form_analysis["vulnerabilities"]:
            severity = vuln["severity"].lower()
            if severity in scan_results["vulnerabilities_summary"]:
                scan_results["vulnerabilities_summary"][severity] += 1

    # Pruebas de inyección SQL y XSS si la profundidad es suficiente
    if scan_depth >= 2:
        # Extraer parámetros de la URL para pruebas
        parsed_url = urlparse(target_url)
        params = {}

        # Si hay parámetros en la URL, usarlos para pruebas
        if parsed_url.query:
            for param in parsed_url.query.split('&'):
                if '=' in param:
                    key, value = param.split('=', 1)
                    params[key] = value

        # Si no hay parámetros, usar parámetros de prueba básicos
        if not params:
            params = {"id": "1", "page": "1", "search": "test"}

        # Pruebas de inyección SQL
        print("[*] Realizando pruebas de inyección SQL...")
        sql_results = test_sql_injection(target_url, params)
        scan_results["sql_injection_tests"] = sql_results

        if sql_results["vulnerable"]:
            scan_results["vulnerabilities_summary"]["high"] += 1
            print(f"[!] Se detectaron posibles vulnerabilidades de inyección SQL.")

        # Pruebas de XSS
        print("[*] Realizando pruebas de Cross-Site Scripting (XSS)...")
        xss_results = test_xss_vulnerability(target_url, params)
        scan_results["xss_tests"] = xss_results

        if xss_results["vulnerable"]:
            scan_results["vulnerabilities_summary"]["high"] += 1
            print(f"[!] Se detectaron posibles vulnerabilidades XSS.")

    # Resumen de vulnerabilidades
    total_vulns = sum(scan_results["vulnerabilities_summary"].values())
    print(
        f"\n[+] Análisis completado. Se encontraron {total_vulns} posibles vulnerabilidades:")
    print(
        f"    - Alta severidad: {scan_results['vulnerabilities_summary']['high']}")
    print(
        f"    - Media severidad: {scan_results['vulnerabilities_summary']['medium']}")
    print(
        f"    - Baja severidad: {scan_results['vulnerabilities_summary']['low']}")
    print(
        f"    - Informativas: {scan_results['vulnerabilities_summary']['info']}")

    return scan_results


def export_web_vulnerability_results(scan_results):
    """Exporta los resultados del análisis de vulnerabilidades web a un archivo JSON

    Args:
        scan_results (dict): Resultados del análisis

    Returns:
        str: Ruta del archivo generado
    """
    try:
        # Crear directorio de resultados si no existe
        output_dir = create_results_directory()

        # Generar nombre de archivo con timestamp
        target_domain = urlparse(scan_results["target_url"]).netloc
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{output_dir}/web_vuln_{target_domain}_{timestamp}.json"

        # Exportar a JSON
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(scan_results, f, indent=4)

        print(f"\n[+] Resultados exportados a: {filename}")
        return filename

    except Exception as e:
        print(f"\n[!] Error al exportar resultados: {e}")
        return None


def display_web_vulnerability_results(scan_results, voice_enabled=True):
    """Muestra los resultados del análisis de vulnerabilidades web de manera organizada

    Args:
        scan_results (dict): Resultados del análisis
        voice_enabled (bool): Indica si el asistente de voz está habilitado
    """
    if not scan_results:
        print("\n[!] No hay resultados para mostrar.")
        return

    print(f"\n{'=' * 60}")
    print(f"RESULTADOS DEL ANÁLISIS DE VULNERABILIDADES WEB")
    print(f"{'=' * 60}\n")

    print(f"URL analizada: {scan_results['target_url']}")
    print(f"Fecha y hora: {scan_results['scan_time']}")
    print(f"Profundidad del análisis: {scan_results['scan_depth']}\n")

    # Resumen de vulnerabilidades
    total_vulns = sum(scan_results["vulnerabilities_summary"].values())
    print(f"RESUMEN DE VULNERABILIDADES:")
    print(f"{'-' * 60}")
    print(f"Total de vulnerabilidades detectadas: {total_vulns}")
    print(
        f"  - Alta severidad: {scan_results['vulnerabilities_summary']['high']}")
    print(
        f"  - Media severidad: {scan_results['vulnerabilities_summary']['medium']}")
    print(
        f"  - Baja severidad: {scan_results['vulnerabilities_summary']['low']}")
    print(
        f"  - Informativas: {scan_results['vulnerabilities_summary']['info']}\n")

    # Cabeceras de seguridad
    print(f"ANÁLISIS DE CABECERAS DE SEGURIDAD:")
    print(f"{'-' * 60}")
    missing_headers = scan_results["security_headers"]["missing_headers"]
    if missing_headers:
        print(f"Cabeceras de seguridad faltantes ({len(missing_headers)}):")
        for header in missing_headers:
            desc = scan_results["security_headers"]["security_headers"][header]["description"]
            print(f"  - {header}: {desc}")
    else:
        print("Todas las cabeceras de seguridad importantes están presentes.")

    print("\nCabeceras de seguridad presentes:")
    for header, info in scan_results["security_headers"]["security_headers"].items():
        if info["present"]:
            print(f"  - {header}: {info['value']}")

    # Formularios analizados
    print(f"\nFORMULARIOS ANALIZADOS:")
    print(f"{'-' * 60}")
    if scan_results["forms_analyzed"]:
        for i, form in enumerate(scan_results["forms_analyzed"], 1):
            print(f"Formulario #{i}:")
            print(f"  - Acción: {form['action']}")
            print(f"  - Método: {form['method']}")
            print(f"  - Campos: {len(form['inputs'])}")

            if form["vulnerabilities"]:
                print(
                    f"  - Vulnerabilidades detectadas ({len(form['vulnerabilities'])}):")
                for vuln in form["vulnerabilities"]:
                    print(
                        f"    * {vuln['type']} (Severidad: {vuln['severity']})")
                    print(f"      {vuln['description']}")
                    print(f"      Recomendación: {vuln['recommendation']}")
            else:
                print("  - No se detectaron vulnerabilidades en este formulario.")
            print()
    else:
        print("No se encontraron formularios para analizar.")

    # Resultados de pruebas de inyección SQL
    if "sql_injection_tests" in scan_results and scan_results["sql_injection_tests"]:
        print(f"PRUEBAS DE INYECCIÓN SQL:")
        print(f"{'-' * 60}")
        sql_tests = scan_results["sql_injection_tests"]

        if sql_tests["vulnerable"]:
            print(
                f"[!] VULNERABILIDAD DETECTADA: El sitio parece ser vulnerable a inyección SQL")
            print(
                f"Payloads exitosos ({len(sql_tests['successful_payloads'])}):")
            for payload in sql_tests["successful_payloads"]:
                print(f"  - Parámetro: {payload['param']}")
                print(f"    Payload: {payload['payload']}")
                if "error_pattern" in payload:
                    print(
                        f"    Patrón de error detectado: {payload['error_pattern']}")
                if "response_change" in payload:
                    print(
                        f"    Cambio en respuesta: {payload['response_change']}")
                print()
        else:
            print("No se detectaron vulnerabilidades de inyección SQL.")

    # Resultados de pruebas XSS
    if "xss_tests" in scan_results and scan_results["xss_tests"]:
        print(f"\nPRUEBAS DE CROSS-SITE SCRIPTING (XSS):")
        print(f"{'-' * 60}")