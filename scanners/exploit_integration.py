#!/usr/bin/env python3

import re
import json
import os
import subprocess
import sys
import requests
import time
from datetime import datetime


def search_exploits_for_service(service_name, version=None):
    """
    Busca exploits disponibles para un servicio específico en ExploitDB

    Args:
        service_name (str): Nombre del servicio
        version (str): Versión del servicio (opcional)

    Returns:
        list: Lista de exploits encontrados
    """
    try:
        print(f"\n[*] Buscando exploits para {service_name}" +
              (f" versión {version}" if version else ""))

        # Construir la consulta de búsqueda
        search_query = service_name
        if version:
            search_query += f" {version}"

        # Intentar usar searchsploit si está disponible (parte de Kali Linux)
        try:
            # Ejecutar searchsploit y capturar la salida
            result = subprocess.run(
                ["searchsploit", "--json", search_query],
                capture_output=True,
                text=True,
                check=False
            )

            if result.returncode == 0 and result.stdout:
                try:
                    # Parsear la salida JSON
                    exploits_data = json.loads(result.stdout)
                    exploits = exploits_data.get("RESULTS_EXPLOIT", [])

                    if exploits:
                        return exploits
                except json.JSONDecodeError:
                    print("[!] Error al parsear la salida de searchsploit")
        except FileNotFoundError:
            print("[!] searchsploit no está disponible en el sistema")

        # Alternativa: Consultar la API de Exploit-DB
        print("[*] Consultando la base de datos online de Exploit-DB...")

        # URL de la API de Exploit-DB
        api_url = "https://www.exploit-db.com/search"

        # Parámetros de búsqueda
        params = {
            "q": search_query,
            "type": "text",
            "platform": "",
            "author": "",
            "port": "",
            "tag": ""
        }

        # Realizar la solicitud
        response = requests.get(api_url, params=params)

        if response.status_code == 200:
            # Extraer información de exploits de la respuesta
            # Nota: Esto es una simplificación, la respuesta real puede requerir un análisis más complejo
            exploits = []

            # Buscar patrones de exploits en la respuesta
            exploit_pattern = r'href="/exploits/(\d+)"[^>]*>([^<]+)</a>'
            matches = re.findall(exploit_pattern, response.text)

            for exploit_id, title in matches:
                exploits.append({
                    "id": exploit_id,
                    "title": title,
                    "url": f"https://www.exploit-db.com/exploits/{exploit_id}"
                })

            return exploits
        else:
            print(f"[!] Error al consultar Exploit-DB: {response.status_code}")
            return []

    except Exception as e:
        print(f"[!] Error al buscar exploits: {e}")
        return []


def search_exploits_for_cve(cve_id):
    """
    Busca exploits disponibles para un CVE específico

    Args:
        cve_id (str): Identificador CVE (ej: CVE-2021-44228)

    Returns:
        list: Lista de exploits encontrados
    """
    try:
        print(f"\n[*] Buscando exploits para {cve_id}")

        # Intentar usar searchsploit si está disponible
        try:
            result = subprocess.run(
                ["searchsploit", "--json", cve_id],
                capture_output=True,
                text=True,
                check=False
            )

            if result.returncode == 0 and result.stdout:
                try:
                    exploits_data = json.loads(result.stdout)
                    exploits = exploits_data.get("RESULTS_EXPLOIT", [])

                    if exploits:
                        return exploits
                except json.JSONDecodeError:
                    print("[!] Error al parsear la salida de searchsploit")
        except FileNotFoundError:
            print("[!] searchsploit no está disponible en el sistema")

        # Alternativa: Consultar la API de NVD (National Vulnerability Database)
        print("[*] Consultando la base de datos NVD...")

        # URL de la API de NVD
        api_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"

        # Realizar la solicitud
        response = requests.get(api_url)

        if response.status_code == 200:
            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])

            if vulnerabilities:
                # Extraer información relevante
                cve_info = vulnerabilities[0].get("cve", {})
                descriptions = cve_info.get("descriptions", [])
                references = cve_info.get("references", [])

                # Construir resultado
                result = {
                    "id": cve_id,
                    "description": next((d.get("value") for d in descriptions if d.get("lang") == "en"), "No description available"),
                    "references": [ref.get("url") for ref in references if ref.get("url")]
                }

                return [result]

        # Si no se encuentra en NVD, consultar Exploit-DB
        return search_exploits_for_service(cve_id)

    except Exception as e:
        print(f"[!] Error al buscar exploits para CVE: {e}")
        return []


def generate_metasploit_commands(service_name, port, target_ip, version=None):
    """
    Genera comandos de Metasploit para explotar vulnerabilidades conocidas

    Args:
        service_name (str): Nombre del servicio
        port (int): Número de puerto
        target_ip (str): Dirección IP objetivo
        version (str): Versión del servicio (opcional)

    Returns:
        list: Lista de comandos de Metasploit sugeridos
    """
    try:
        print(f"\n[*] Generando comandos de Metasploit para {service_name}" +
              (f" versión {version}" if version else ""))

        # Mapeo de servicios comunes a módulos de Metasploit
        metasploit_modules = {
            "ftp": [
                f"use auxiliary/scanner/ftp/ftp_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "set USER_FILE /usr/share/wordlists/metasploit/unix_users.txt",
                "set PASS_FILE /usr/share/wordlists/metasploit/unix_passwords.txt",
                "run"
            ],
            "ssh": [
                f"use auxiliary/scanner/ssh/ssh_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "set USER_FILE /usr/share/wordlists/metasploit/unix_users.txt",
                "set PASS_FILE /usr/share/wordlists/metasploit/unix_passwords.txt",
                "run"
            ],
            "telnet": [
                f"use auxiliary/scanner/telnet/telnet_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "set USER_FILE /usr/share/wordlists/metasploit/unix_users.txt",
                "set PASS_FILE /usr/share/wordlists/metasploit/unix_passwords.txt",
                "run"
            ],
            "smtp": [
                f"use auxiliary/scanner/smtp/smtp_enum",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "http": [
                f"use auxiliary/scanner/http/dir_scanner",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "https": [
                f"use auxiliary/scanner/http/dir_scanner",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "set SSL true",
                "run"
            ],
            "smb": [
                f"use auxiliary/scanner/smb/smb_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "mysql": [
                f"use auxiliary/scanner/mysql/mysql_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "mssql": [
                f"use auxiliary/scanner/mssql/mssql_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "postgresql": [
                f"use auxiliary/scanner/postgres/postgres_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "vnc": [
                f"use auxiliary/scanner/vnc/vnc_login",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ],
            "rdp": [
                f"use auxiliary/scanner/rdp/rdp_scanner",
                f"set RHOSTS {target_ip}",
                f"set RPORT {port}",
                "run"
            ]
        }

        # Buscar módulos específicos para la versión si está disponible
        if version and service_name.lower() in ["apache", "nginx", "iis", "tomcat"]:
            # Ejemplo para Apache con vulnerabilidades conocidas
            if service_name.lower() == "apache" and "2.4." in version and float(version.split("2.4.")[1]) < 50:
                return [
                    f"use exploit/unix/http/apache_mod_cgi_bash_env_exec",
                    f"set RHOSTS {target_ip}",
                    f"set RPORT {port}",
                    "set TARGETURI /cgi-bin/",
                    "check",
                    "# Si el check es exitoso, ejecuta: run"
                ]

        # Devolver comandos para el servicio si está en el mapeo
        service_key = service_name.lower()
        for key in metasploit_modules.keys():
            if key in service_key:
                return metasploit_modules[key]

        # Si no hay un módulo específico, devolver un escaneo genérico
        return [
            f"use auxiliary/scanner/discovery/udp_sweep",
            f"set RHOSTS {target_ip}",
            "run",
            "",
            f"use auxiliary/scanner/portscan/tcp",
            f"set RHOSTS {target_ip}",
            f"set PORTS {port}",
            "run"
        ]

    except Exception as e:
        print(f"[!] Error al generar comandos de Metasploit: {e}")
        return []


def analyze_vulnerabilities_and_suggest_exploits(scan_results, target_ip):
    """
    Analiza los resultados del escaneo para identificar vulnerabilidades y sugerir exploits

    Args:
        scan_results (PortScanner): Objeto con los resultados del escaneo
        target_ip (str): La dirección IP escaneada

    Returns:
        dict: Diccionario con vulnerabilidades y exploits sugeridos
    """
    try:
        if target_ip not in scan_results.all_hosts():
            print(f"\n[!] No se encontró información para la IP {target_ip}")
            return {}

        print(f"\n{'=' * 60}")
        print(f"ANÁLISIS DE VULNERABILIDADES Y EXPLOITS PARA: {target_ip}")
        print(f"{'=' * 60}\n")

        # Diccionario para almacenar resultados
        vulnerability_analysis = {
            "target": target_ip,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "services": [],
            "cves": [],
            "exploit_suggestions": []
        }

        # Analizar cada protocolo y puerto
        for proto in scan_results[target_ip].all_protocols():
            ports = sorted(scan_results[target_ip][proto].keys())

            for port in ports:
                port_info = scan_results[target_ip][proto][port]
                state = port_info['state']
                service = port_info.get('name', 'desconocido')
                version = port_info.get('product', '')
                version_details = port_info.get('version', '')

                # Construir la información de versión completa
                full_version = version
                if version_details:
                    full_version += f" {version_details}"

                print(
                    f"\n[*] Analizando puerto {port}/{proto} - {service} {full_version}")

                # Almacenar información del servicio
                service_info = {
                    "port": port,
                    "protocol": proto,
                    "service": service,
                    "version": full_version,
                    "state": state,
                    "vulnerabilities": []
                }

                # Buscar vulnerabilidades en los scripts
                cves_found = []
                if 'script' in port_info:
                    for script_name, output in port_info['script'].items():
                        if any(vuln_term in script_name.lower() for vuln_term in ['vuln', 'exploit', 'cve']):
                            print(
                                f"  - Vulnerabilidad detectada: {script_name}")

                            # Buscar CVEs en la salida del script
                            cve_pattern = r'CVE-\d{4}-\d{4,7}'
                            cves = re.findall(cve_pattern, output)

                            for cve in set(cves):  # Eliminar duplicados
                                if cve not in cves_found:
                                    cves_found.append(cve)
                                    print(f"    - CVE detectado: {cve}")

                                    # Buscar exploits para este CVE
                                    exploits = search_exploits_for_cve(cve)

                                    if exploits:
                                        print(
                                            f"    - Exploits encontrados para {cve}: {len(exploits)}")
                                        for exploit in exploits:
                                            exploit_id = exploit.get(
                                                'id', 'N/A')
                                            exploit_title = exploit.get(
                                                'title', exploit.get('description', 'Sin título'))
                                            print(
                                                f"      * {exploit_id}: {exploit_title}")

                                            # Agregar a las sugerencias de exploits
                                            vulnerability_analysis["exploit_suggestions"].append({
                                                "type": "cve",
                                                "cve_id": cve,
                                                "exploit_id": exploit_id,
                                                "title": exploit_title,
                                                "port": port,
                                                "service": service
                                            })

                                    # Agregar CVE a la lista general
                                    vulnerability_analysis["cves"].append({
                                        "id": cve,
                                        "port": port,
                                        "service": service,
                                        "exploits_available": len(exploits) > 0
                                    })

                                    # Agregar a las vulnerabilidades del servicio
                                    service_info["vulnerabilities"].append({
                                        "type": "cve",
                                        "id": cve,
                                        "details": output,
                                        "exploits_available": len(exploits) > 0
                                    })

                # Si no se encontraron CVEs específicos, buscar exploits basados en el servicio y versión
                if not cves_found and service != 'desconocido':
                    print(
                        f"  - Buscando exploits basados en el servicio: {service} {full_version}")
                    service_exploits = search_exploits_for_service(
                        service, full_version)

                    if service_exploits:
                        print(
                            f"  - Exploits encontrados para {service}: {len(service_exploits)}")
                        for exploit in service_exploits:
                            exploit_id = exploit.get('id', 'N/A')
                            exploit_title = exploit.get(
                                'title', exploit.get('description', 'Sin título'))
                            print(f"    * {exploit_id}: {exploit_title}")

                            # Agregar a las sugerencias de exploits
                            vulnerability_analysis["exploit_suggestions"].append({
                                "type": "service",
                                "service": service,
                                "version": full_version,
                                "exploit_id": exploit_id,
                                "title": exploit_title,
                                "port": port
                            })

                            # Agregar a las vulnerabilidades del servicio
                            service_info["vulnerabilities"].append({
                                "type": "service_version",
                                "details": f"Posible vulnerabilidad en {service} {full_version}",
                                "exploit_id": exploit_id,
                                "exploit_title": exploit_title
                            })

                # Generar comandos de Metasploit para este servicio
                metasploit_commands = generate_metasploit_commands(
                    service, port, target_ip, full_version)
                if metasploit_commands:
                    print("\n  - Comandos de Metasploit sugeridos:")
                    for cmd in metasploit_commands:
                        print(f"    {cmd}")

                    # Agregar comandos a la información del servicio
                    service_info["metasploit_commands"] = metasploit_commands

                # Agregar información del servicio al análisis
                vulnerability_analysis["services"].append(service_info)

        # Resumen final
        print(f"\n{'=' * 60}")
        print("RESUMEN DEL ANÁLISIS DE VULNERABILIDADES")
        print(f"{'=' * 60}")
        print(
            f"Servicios analizados: {len(vulnerability_analysis['services'])}")
        print(f"CVEs detectados: {len(vulnerability_analysis['cves'])}")
        print(
            f"Exploits sugeridos: {len(vulnerability_analysis['exploit_suggestions'])}")

        return vulnerability_analysis

    except Exception as e:
        print(f"\n[!] Error al analizar vulnerabilidades: {e}")
        return {}


def export_vulnerability_analysis(analysis_results, target_ip):
    """
    Exporta los resultados del análisis de vulnerabilidades a un archivo JSON

    Args:
        analysis_results (dict): Resultados del análisis de vulnerabilidades
        target_ip (str): La dirección IP analizada

    Returns:
        str: Ruta del archivo generado
    """
    try:
        # Crear directorio de resultados si no existe
        output_dir = "resultados_analisis"
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Generar nombre de archivo con timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{output_dir}/analisis_vulnerabilidades_{target_ip.replace('.', '_')}_{timestamp}.json"

        # Exportar a JSON
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(analysis_results, f, indent=4)

        print(f"\n[+] Análisis de vulnerabilidades exportado a: {filename}")
        return filename

    except Exception as e:
        print(f"\n[!] Error al exportar análisis de vulnerabilidades: {e}")
        return None